{"version":3,"names":["_timers","require","_wrapAsync","_clear","_press","_scroll","_type","_utils","universalJestAdvanceTimersBy","ms","jestFakeTimersAreEnabled","jest","advanceTimersByTime","Promise","resolve","defaultOptions","delay","advanceTimers","setup","options","config","createConfig","instance","createInstance","Object","assign","api","press","wrapAndBindImpl","longPress","type","clear","scrollTo","impl","method","_len","arguments","length","args","Array","_key","wrapAsync","apply","then","_ref","_asyncToGenerator2","default","result","wait","_x","defineProperty","get","name"],"sources":["../../../src/user-event/setup/setup.ts"],"sourcesContent":["import { ReactTestInstance } from 'react-test-renderer';\nimport { jestFakeTimersAreEnabled } from '../../helpers/timers';\nimport { wrapAsync } from '../../helpers/wrap-async';\nimport { clear } from '../clear';\nimport { PressOptions, press, longPress } from '../press';\nimport { ScrollToOptions, scrollTo } from '../scroll';\nimport { TypeOptions, type } from '../type';\nimport { wait } from '../utils';\n\nexport interface UserEventSetupOptions {\n  /**\n   * Between some subsequent inputs like typing a series of characters\n   * the code execution is delayed per `setTimeout` for (at least) `delay` seconds.\n   * This moves the next changes at least to next macro task\n   * and allows other (asynchronous) code to run between events.\n   *\n   * `null` prevents `setTimeout` from being called.\n   *\n   * @default 0\n   */\n  delay?: number;\n\n  /**\n   * Function to be called to advance fake timers. Setting it is necessary for\n   * fake timers to work.\n   *\n   * @example jest.advanceTimersByTime\n   */\n  advanceTimers?: (delay: number) => Promise<void> | void;\n}\n\n/**\n * This functions allow wait to work correctly under both real and fake Jest timers.\n */\nfunction universalJestAdvanceTimersBy(ms: number) {\n  if (jestFakeTimersAreEnabled()) {\n    return jest.advanceTimersByTime(ms);\n  } else {\n    return Promise.resolve();\n  }\n}\n\nconst defaultOptions: Required<UserEventSetupOptions> = {\n  delay: 0,\n  advanceTimers: universalJestAdvanceTimersBy,\n};\n\n/**\n * Creates a new instance of user event instance with the given options.\n *\n * @param options\n * @returns UserEvent instance\n */\nexport function setup(options?: UserEventSetupOptions) {\n  const config = createConfig(options);\n  const instance = createInstance(config);\n  return instance;\n}\n\n/**\n * Options affecting all user event interactions.\n *\n * @param delay between some subsequent inputs like typing a series of characters\n * @param advanceTimers function to be called to advance fake timers\n */\nexport interface UserEventConfig {\n  delay: number;\n  advanceTimers: (delay: number) => Promise<void> | void;\n}\n\nfunction createConfig(options?: UserEventSetupOptions): UserEventConfig {\n  return {\n    ...defaultOptions,\n    ...options,\n  };\n}\n\n/**\n * UserEvent instance used to invoke user interaction functions.\n */\nexport interface UserEventInstance {\n  config: UserEventConfig;\n\n  press: (element: ReactTestInstance) => Promise<void>;\n  longPress: (element: ReactTestInstance, options?: PressOptions) => Promise<void>;\n\n  /**\n   * Simulate user pressing on a given `TextInput` element and typing given text.\n   *\n   * This method will trigger the events for each character of the text:\n   * `keyPress`, `change`, `changeText`, `endEditing`, etc.\n   *\n   * It will also trigger events connected with entering and leaving the text\n   * input.\n   *\n   * The exact events sent depend on the props of the TextInput (`editable`,\n   * `multiline`, value, defaultValue, etc) and passed options.\n   *\n   * @param element TextInput element to type on\n   * @param text Text to type\n   * @param options Options affecting typing behavior:\n   *  - `skipPress` - if true, `pressIn` and `pressOut` events will not be\n   *   triggered.\n   * - `submitEditing` - if true, `submitEditing` event will be triggered after\n   * typing the text.\n   */\n  type: (element: ReactTestInstance, text: string, options?: TypeOptions) => Promise<void>;\n\n  /**\n   * Simulate user clearing the text of a given `TextInput` element.\n   *\n   * This method will simulate:\n   * 1. entering TextInput\n   * 2. selecting all text\n   * 3. pressing backspace to delete all text\n   * 4. leaving TextInput\n   *\n   * @param element TextInput element to clear\n   */\n  clear: (element: ReactTestInstance) => Promise<void>;\n\n  /**\n   * Simlate user scorlling a ScrollView element.\n   *\n   * @param element ScrollView element\n   * @returns\n   */\n  scrollTo: (element: ReactTestInstance, options: ScrollToOptions) => Promise<void>;\n}\n\nfunction createInstance(config: UserEventConfig): UserEventInstance {\n  const instance = {\n    config,\n  } as UserEventInstance;\n\n  // Bind interactions to given User Event instance.\n  const api = {\n    press: wrapAndBindImpl(instance, press),\n    longPress: wrapAndBindImpl(instance, longPress),\n    type: wrapAndBindImpl(instance, type),\n    clear: wrapAndBindImpl(instance, clear),\n    scrollTo: wrapAndBindImpl(instance, scrollTo),\n  };\n\n  Object.assign(instance, api);\n  return instance;\n}\n\n/**\n * Wraps user interaction with `wrapAsync` (temporarily disable `act` environment while\n * calling & resolving the async callback, then flush the microtask queue)\n *\n * This implementation is sourced from `testing-library/user-event`\n * @see https://github.com/testing-library/user-event/blob/7a305dee9ab833d6f338d567fc2e862b4838b76a/src/setup/setup.ts#L121\n */\nfunction wrapAndBindImpl<\n  Args extends any[],\n  Impl extends (this: UserEventInstance, ...args: Args) => Promise<unknown>,\n>(instance: UserEventInstance, impl: Impl) {\n  function method(...args: Args) {\n    return wrapAsync(() =>\n      // eslint-disable-next-line promise/prefer-await-to-then\n      impl.apply(instance, args).then(async (result) => {\n        await wait(instance.config);\n        return result;\n      }),\n    );\n  }\n\n  // Copy implementation name to the returned function\n  Object.defineProperty(method, 'name', { get: () => impl.name });\n\n  return method as Impl;\n}\n"],"mappings":";;;;;;;;AACA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,UAAA,GAAAD,OAAA;AACA,IAAAE,MAAA,GAAAF,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AACA,IAAAI,OAAA,GAAAJ,OAAA;AACA,IAAAK,KAAA,GAAAL,OAAA;AACA,IAAAM,MAAA,GAAAN,OAAA;AA2BA,SAASO,4BAA4BA,CAACC,EAAU,EAAE;EAChD,IAAI,IAAAT,OAAA,CAAAU,wBAAwB,EAAC,CAAC,EAAE;IAC9B,OAAOC,IAAI,CAACC,mBAAmB,CAACH,EAAE,CAAC;EACrC,CAAC,MAAM;IACL,OAAOI,OAAO,CAACC,OAAO,CAAC,CAAC;EAC1B;AACF;AAEA,IAAMC,cAA+C,GAAG;EACtDC,KAAK,EAAE,CAAC;EACRC,aAAa,EAAET;AACjB,CAAC;AAQM,SAASU,KAAKA,CAACC,OAA+B,EAAE;EACrD,IAAMC,MAAM,GAAGC,YAAY,CAACF,OAAO,CAAC;EACpC,IAAMG,QAAQ,GAAGC,cAAc,CAACH,MAAM,CAAC;EACvC,OAAOE,QAAQ;AACjB;AAaA,SAASD,YAAYA,CAACF,OAA+B,EAAmB;EACtE,OAAAK,MAAA,CAAAC,MAAA,KACKV,cAAc,EACdI,OAAA;AAEP;AAuDA,SAASI,cAAcA,CAACH,MAAuB,EAAqB;EAClE,IAAME,QAAQ,GAAG;IACfF,MAAA,EAAAA;EACF,CAAsB;EAGtB,IAAMM,GAAG,GAAG;IACVC,KAAK,EAAEC,eAAe,CAACN,QAAQ,EAAElB,MAAA,CAAAuB,KAAK,CAAC;IACvCE,SAAS,EAAED,eAAe,CAACN,QAAQ,EAAElB,MAAA,CAAAyB,SAAS,CAAC;IAC/CC,IAAI,EAAEF,eAAe,CAACN,QAAQ,EAAEhB,KAAA,CAAAwB,IAAI,CAAC;IACrCC,KAAK,EAAEH,eAAe,CAACN,QAAQ,EAAEnB,MAAA,CAAA4B,KAAK,CAAC;IACvCC,QAAQ,EAAEJ,eAAe,CAACN,QAAQ,EAAEjB,OAAA,CAAA2B,QAAQ;EAC9C,CAAC;EAEDR,MAAM,CAACC,MAAM,CAACH,QAAQ,EAAEI,GAAG,CAAC;EAC5B,OAAOJ,QAAQ;AACjB;AASA,SAASM,eAAeA,CAGtBN,QAA2B,EAAEW,IAAU,EAAE;EACzC,SAASC,MAAMA,CAAA,EAAgB;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAZC,IAAU,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAVF,IAAU,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IAC3B,OAAO,IAAAtC,UAAA,CAAAuC,SAAS,EAAC;MAAA,OAEfR,IAAI,CAACS,KAAK,CAACpB,QAAQ,EAAEgB,IAAI,CAAC,CAACK,IAAI;QAAA,IAAAC,IAAA,OAAAC,kBAAA,CAAAC,OAAA,EAAC,WAAOC,MAAM,EAAK;UAChD,MAAM,IAAAxC,MAAA,CAAAyC,IAAI,EAAC1B,QAAQ,CAACF,MAAM,CAAC;UAC3B,OAAO2B,MAAM;QACf,CAAC;QAAA,iBAAAE,EAAA;UAAA,OAAAL,IAAA,CAAAF,KAAA,OAAAN,SAAA;QAAA;MAAA,IACH;IAAA,EAAC;EACH;EAGAZ,MAAM,CAAC0B,cAAc,CAAChB,MAAM,EAAE,MAAM,EAAE;IAAEiB,GAAG,EAAE,SAAAA,IAAA;MAAA,OAAMlB,IAAI,CAACmB,IAAA;IAAA;EAAK,CAAC,CAAC;EAE/D,OAAOlB,MAAM;AACf","ignoreList":[]}